// Generated by CoffeeScript 1.6.3
(function() {
  var EngineProtocol, EngineServer, EngineWebsocketServer, Q, WebsocketListener, helpers, stump, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  stump = require('stump');

  Q = require('q');

  WebsocketListener = require('./ws_listener');

  EngineProtocol = require('./e_protocol');

  EngineServer = require('../engine_server');

  helpers = require('enkihelpers');

  module.exports = EngineWebsocketServer = (function(_super) {
    __extends(EngineWebsocketServer, _super);

    EngineWebsocketServer.default_options = {
      port: 6150,
      journalname: 'engine.testjournal'
    };

    function EngineWebsocketServer(options) {
      if (options == null) {
        options = {};
      }
      this.send_all = __bind(this.send_all, this);
      this.connection_lost = __bind(this.connection_lost, this);
      this.new_connection = __bind(this.new_connection, this);
      this.stop = __bind(this.stop, this);
      this.start = __bind(this.start, this);
      options = _.extend(EngineWebsocketServer.default_options, options);
      EngineWebsocketServer.__super__.constructor.call(this, options);
    }

    EngineWebsocketServer.prototype.start = function() {
      var _this = this;
      this.connection_map = {};
      this.closed = false;
      return this.pce.start().then(function() {
        _this.listener = new WebsocketListener({
          wsconfig: {
            port: _this.options.port
          },
          protocol_factory: _this.new_connection
        });
        return _this.listener.listen();
      });
    };

    EngineWebsocketServer.prototype.stop = function() {
      var cop,
        _this = this;
      if (this.closed) {
        throw Error('ALREADY CLOSED');
      }
      this.closed = true;
      this.info('SHUTTING DOWN');
      cop = helpers.extend({}, this.connection_map);
      this.connection_map = {};
      return this.listener.close().then(function() {
        var x, y;
        _this.info('LISTENER CLOSED');
        return Q.all([
          (function() {
            var _results;
            _results = [];
            for (x in cop) {
              y = cop[x];
              _results.push(y.disconnect());
            }
            return _results;
          })()
        ]).then(function() {
          _this.info('ALL CONNS CLOSED');
          return true;
        });
      });
    };

    EngineWebsocketServer.prototype.new_connection = function(connection) {
      var protocol;
      this.connection_map[connection.conncounter] = connection;
      protocol = new EngineProtocol({
        pce: this.pce,
        connection_lost: this.connection_lost,
        send_all: this.send_all
      });
      return protocol.start(connection);
    };

    EngineWebsocketServer.prototype.connection_lost = function(connection) {
      return delete this.connection_map[connection.conncounter];
    };

    EngineWebsocketServer.prototype.send_all = function(obj) {
      var x, y, _ref, _results;
      _ref = this.connection_map;
      _results = [];
      for (x in _ref) {
        y = _ref[x];
        console.log(x);
        _results.push(y.send_obj(obj));
      }
      return _results;
    };

    return EngineWebsocketServer;

  })(EngineServer);

}).call(this);
