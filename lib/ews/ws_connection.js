// Generated by CoffeeScript 1.6.3
(function() {
  var Connection, EventEmitter, Q, WebSocket, globalconncounter, helpers, is_node, stump, wrap_error,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  WebSocket = require('wsany');

  is_node = require('isnode');

  Q = require('q');

  helpers = require('enkihelpers');

  wrap_error = helpers.wrap_error;

  stump = require('stump');

  EventEmitter = require('chained-emitter').EventEmitter;

  globalconncounter = 0;

  module.exports = Connection = (function(_super) {
    __extends(Connection, _super);

    function Connection(parent) {
      var deferred;
      this.parent = parent;
      this.disconnect = __bind(this.disconnect, this);
      this.send_raw = __bind(this.send_raw, this);
      this.send_obj = __bind(this.send_obj, this);
      this.handle_data = __bind(this.handle_data, this);
      this.handle_close = __bind(this.handle_close, this);
      this.handle_open = __bind(this.handle_open, this);
      this.handle_error = __bind(this.handle_error, this);
      this.uncaught_exception = __bind(this.uncaught_exception, this);
      this._get_obj_desc = __bind(this._get_obj_desc, this);
      this.prepare_ws = __bind(this.prepare_ws, this);
      this.connect = __bind(this.connect, this);
      this.socket_accepted = __bind(this.socket_accepted, this);
      this.parent.stumpify(this, this._get_obj_desc);
      this.conncounter = globalconncounter;
      globalconncounter += 1;
      this.ws = null;
      deferred = Q.defer();
      this.senddeferred = deferred;
    }

    Connection.prototype.socket_accepted = function(ws) {
      this.ws = ws;
      this.prepare_ws();
      this.senddeferred.resolve(this.ws.send);
      return wrap_error(this.handle_open, this.uncaught_exception)();
    };

    Connection.prototype.connect = function(wsconfig) {
      var _this = this;
      this.info('STARTING TO CONNECT:', wsconfig);
      this.ws = new WebSocket(wsconfig);
      this.prepare_ws();
      this.once('open', function() {
        _this.info('ONCEOPEN');
        return _this.senddeferred.resolve(_this.ws.send);
      });
      return this.once('close', function() {
        _this.info('ONCECLOSE');
        return _this.senddeferred.reject("Connection closed");
      });
    };

    Connection.prototype.prepare_ws = function() {
      this.ws.on('error', this.handle_error);
      this.ws.on('open', wrap_error(this.handle_open, this.uncaught_exception));
      this.ws.on('close', wrap_error(this.handle_close, this.uncaught_exception));
      return this.ws.on('message', wrap_error(this.handle_data, this.uncaught_exception));
    };

    Connection.prototype._get_obj_desc = function() {
      return this.constructor.name + ' #' + this.conncounter;
    };

    Connection.prototype.uncaught_exception = function(exc) {
      throw exc;
    };

    Connection.prototype.handle_error = function(error) {
      this.error(error);
      throw error;
    };

    Connection.prototype.handle_open = function() {
      this.info('handle_open');
      return this.emit('open', this);
    };

    Connection.prototype.handle_close = function() {
      this.info('Connection Closed');
      return this.emit('close');
    };

    Connection.prototype.handle_data = function(data, flags) {
      var obj;
      obj = JSON.parse(data);
      return this.emit('parsed_data', obj);
    };

    Connection.prototype.send_obj = function(objOrPromise) {
      var _this = this;
      return Q.when(objOrPromise).then(function(obj) {
        return _this.send_raw(JSON.stringify(obj));
      });
    };

    Connection.prototype.send_raw = function(data) {
      var _this = this;
      return Q.invoke(this.senddeferred.promise, "call", this.ws, data).fail(function(error) {
        _this.warn('FAILED TO SEND. SHUTTING DOWN PROTOCOL');
        return Q.reject(error);
      });
    };

    Connection.prototype.disconnect = function() {
      var deferred;
      this.info('CLOSING');
      deferred = Q.defer();
      this.ws.once('close', deferred.resolve);
      this.ws.close();
      return deferred.promise;
    };

    return Connection;

  })(EventEmitter);

}).call(this);
