// Generated by CoffeeScript 1.6.3
(function() {
  var Journal, Ops, Q, QFS, fs, kTestFilename, logger;

  Q = require('q');

  QFS = require("q-io/fs");

  fs = require('fs');

  Journal = require('../lib/journal');

  Ops = require('../lib/operations');

  logger = require('../lib/logger');

  kTestFilename = 'test.log';

  describe('Journal', function() {
    setup_mocking(this);
    beforeEach(function() {
      TestHelper.remove_log(kTestFilename);
      return this.journal = new Journal(kTestFilename);
    });
    afterEach(function() {
      return TestHelper.remove_log(kTestFilename);
    });
    it('should create a log file if it doesn\'t exist', function(done) {
      var _this = this;
      this.mockify('journal');
      this._journal.expects('initialize_log').once().withArgs();
      return this.journal.start().then(function() {
        return done();
      });
    });
    it('should replay a log file if it already exists', function(done) {
      var execute_operation, exists_stub,
        _this = this;
      this.mockify('journal');
      exists_stub = sinon.stub(QFS, 'exists');
      exists_stub.returns({
        then: function(cb) {
          return cb(true);
        }
      });
      execute_operation = function() {};
      this._journal.expects('replay_log').once().withArgs(execute_operation).returns({
        then: function(cb) {
          return cb();
        }
      });
      this._journal.expects('initialize_log').once().withArgs("a");
      return this.journal.start(execute_operation).then(function() {
        exists_stub.restore();
        return done();
      });
    });
    it('should flush the log file when shutting down', function(done) {
      var fakefile, qmock;
      fakefile = {};
      qmock = this.mockify(Q);
      qmock.expects('nfcall').once().withArgs(fs.fsync, fakefile).returns({
        then: function(cb) {
          return cb();
        }
      });
      qmock.expects('nfcall').once().withArgs(fs.close, fakefile).returns({
        then: function(cb) {
          return cb();
        }
      });
      this.journal.writefd = fakefile;
      this.journal.shutdown();
      expect(this.journal.writefd).to.equal(null);
      return done();
    });
    it('should open the log file when initializing', function(done) {
      var fakefile, qmock;
      fakefile = {};
      qmock = this.mockify(Q);
      qmock.expects('nfcall').once().withArgs(fs.open, kTestFilename, "w").returns({
        then: function(cb) {
          return cb(fakefile);
        }
      });
      this.journal.initialize_log();
      expect(this.journal.writefd).to.equal(fakefile);
      return done();
    });
    describe('.replay_log', function() {
      xit('should open the log file in read mode');
      xit('should raise an error if the read fails');
      return xit('should execute a callback for each log item');
    });
    describe('.record', function() {
      xit('should return an empty promise when there is no open log file');
      xit('should write a valid log item');
      return xit('should raise an error on an invalid log item');
    });
    it('should initialize', function(finish) {
      var _this = this;
      return this.journal.start(function(op) {
        return console.log('EXECUTE OP', op);
      }).then(function() {
        console.log('FINISHED');
        assert(_this.journal.filename === kTestFilename);
        return _this.journal.shutdown().then(function() {
          return finish();
        });
      }).done();
    });
    it('should initialize if the log file already exists', function(finish) {
      var journal,
        _this = this;
      logger.info('test journal');
      journal = new Journal(kTestFilename);
      return journal.start(function(op) {
        return console.log('EXECUTE OP', op);
      }).then(function() {
        assert(journal.filename === kTestFilename);
        return journal.shutdown().then(function() {
          return journal.start(function(op) {
            return console.log('EXECUTE OP', op);
          }).then(function() {
            assert(journal.filename === kTestFilename);
            return journal.shutdown().then(function() {
              return finish();
            });
          });
        });
      }).done();
    });
    return it('should record a message correctly', function(finish) {
      var journal,
        _this = this;
      journal = new Journal(kTestFilename);
      return journal.start(function(op) {
        return console.log('EXECUTE OP', op);
      }).then(function() {
        var msg, raw_msg;
        raw_msg = [Ops.ADD_DEPOSIT, "fake"];
        msg = JSON.stringify(raw_msg);
        return journal.record(msg);
      }).then(function() {
        journal.flush();
        return journal.shutdown().then(function() {
          assert(fs.existsSync(kTestFilename));
          return finish();
        });
      }).done();
    });
  });

}).call(this);
