// Generated by CoffeeScript 1.6.3
(function() {
  var Journal, ProcessingChainEntrance, TradeEngine, kTestFilename;

  ProcessingChainEntrance = require('../lib/pce');

  TradeEngine = require('../lib/trade_engine');

  Journal = require('../lib/journal');

  kTestFilename = 'test.log';

  describe('ProcessingChainEntrance', function() {
    setup_mocking();
    beforeEach(function() {
      this.journal = new Journal(kTestFilename);
      this.engine = new TradeEngine();
      this.mockify('journal');
      this.mockify('engine');
      return this.pce = new ProcessingChainEntrance(this.engine, this.journal);
    });
    it('should intialize the transaction log and when starting', function(finish) {
      this._journal.expects('start').once().returns({
        then: function() {}
      });
      this.pce.start();
      return finish();
    });
    it('should log and execute a message upon receiving it', function(finish) {
      var deferred, messageJsonResult, onComplete, operation, operationResult;
      deferred = Q.defer();
      deferred.resolve(void 0);
      operation = {
        kind: "TEST"
      };
      operationResult = {
        kind: "TEST",
        serial: 0
      };
      messageJsonResult = JSON.stringify(operationResult);
      this._journal.expects('record').once().withArgs(messageJsonResult).returns(deferred.promise);
      this._engine.expects('execute_operation').once().withArgs(operationResult).returns("success");
      onComplete = function(result) {
        result.retval.should.equal("success");
        JSON.stringify(result.operation).should.equal(messageJsonResult);
        return finish();
      };
      return this.pce.forward_operation(operation).then(onComplete).done();
    });
    it('should fail when encountering an out of order serial', function(finish) {
      var deferred, messageJsonResult1, onComplete1, operation1, operation5, operationResult1,
        _this = this;
      deferred = Q.defer();
      deferred.resolve(void 0);
      operation1 = {
        kind: "TEST"
      };
      operationResult1 = {
        kind: "TEST",
        serial: 0
      };
      messageJsonResult1 = JSON.stringify(operationResult1);
      this._journal.expects('record').once().withArgs(messageJsonResult1).returns(deferred.promise);
      this._engine.expects('execute_operation').once().withArgs(operationResult1).returns("success");
      operation5 = {
        kind: "TEST",
        serial: 5
      };
      onComplete1 = function(result) {
        result.retval.should.equal("success");
        JSON.stringify(result.operation).should.equal(messageJsonResult1);
        return true;
      };
      return this.pce.forward_operation(operation1).then(onComplete1).then(function() {
        expect(function() {
          return _this.pce.forward_operation(operation5);
        }).to["throw"]("Serial Number 5 != 1");
        return finish();
      }).done();
    });
    it('should throw an error immediately when operation is null', function(finish) {
      var _this = this;
      expect(function() {
        return _this.pce.forward_operation(null).done();
      }).to["throw"]("No Operation supplied");
      return finish();
    });
    return it('should throw an error immediately when the execution fails', function(finish) {
      var _this = this;
      expect(function() {
        return _this.pce.forward_operation({
          'foo': 'bar'
        }).done();
      }).to["throw"]("Invalid Operation");
      return finish();
    });
  });

}).call(this);
