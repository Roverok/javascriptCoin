// Generated by CoffeeScript 1.6.3
(function() {
  var Amount, Order, TestHelper, amt, ensureKeys, fs,
    __slice = [].slice;

  global.chai = require('chai');

  global.expect = chai.expect;

  global.assert = chai.assert;

  global.sinon = require('sinon');

  chai.should();

  global.logger = require('../lib/logger');

  global.Q = require('q');

  Order = require('../lib/datastore/order');

  Amount = require('../lib/datastore/amount');

  fs = require('fs');

  chai.use(function(_chai, utils) {
    chai.Assertion.addMethod('equal_amount', function(amt) {
      var obj;
      obj = utils.flag(this, 'object');
      return this.assert(obj.eq(amt), "Expected " + obj + " to equal " + amt, "Expected " + obj + " not to equal " + amt);
    });
    chai.Assertion.addMethod('equal_ratio', function(ratio) {
      var obj;
      obj = utils.flag(this, 'object');
      return this.assert(obj.eq(ratio), "Expected " + obj + " to equal " + ratio, "Expected " + obj + " not to equal " + ratio);
    });
    return chai.Assertion.addMethod('succeed_with', function(kind) {
      var obj;
      obj = utils.flag(this, 'object');
      this.assert(obj.status === 'success', "Expected #\{this} to have status of success but got " + obj.status, "Expected #\{this} not to have status of ");
      return this.assert(obj.kind === kind, "Expected #\{this} to have kind of " + kind + " but got " + obj.kind, "Expected #\{this} not to have kind of " + kind + " (got " + obj.kind);
    });
  });

  global.setup_mocking = function() {
    this.beforeEach(function() {
      this.mockify || (this.mockify = function(key) {
        var obj;
        obj = (typeof key) === 'string' ? this[key] : key;
        this.mocks.unshift(sinon.mock(obj));
        if ((typeof key) === 'string') {
          this["_" + key] = this.mocks[0];
        }
        return this.mocks[0];
      });
      return this.mocks = [];
    });
    return this.afterEach(function() {
      var m, _, _ref, _results;
      _ref = this.mocks;
      _results = [];
      for (_ in _ref) {
        m = _ref[_];
        m.verify();
        _results.push(m.restore());
      }
      return _results;
    });
  };

  TestHelper = (function() {
    function TestHelper() {}

    TestHelper.remove_log = function(filename) {
      if (filename == null) {
        filename = 'test.log';
      }
      if (fs.existsSync(filename)) {
        return fs.unlinkSync(filename);
      }
    };

    return TestHelper;

  })();

  global.TestHelper = TestHelper;

  amt = function(x) {
    return new Amount(x != null ? x.toString() : void 0);
  };

  global.buyBTC = function(acct, numBtc, numDollars) {
    acct.credit('USD', amt(numDollars));
    return acct.create_order('USD', amt(numDollars), 'BTC', amt(numBtc));
  };

  global.sellBTC = function(acct, numBtc, numDollars) {
    acct.credit('BTC', amt(numBtc));
    return acct.create_order('BTC', amt(numBtc), 'USD', amt(numDollars));
  };

  global.logResults = function(results) {
    var displayOpened, displaySold, x, _results;
    displaySold = function(x) {
      return console.log("\t" + x.account.name + " sold " + x.received_amount + " " + x.received_currency + " for " + x.offered_amount + " " + x.offered_currency);
    };
    displayOpened = function(x) {
      return console.log("\t" + x.account.name + " listed " + x.received_amount + " " + x.received_currency + " for " + x.offered_amount + " " + x.offered_currency);
    };
    _results = [];
    while (results.length > 0) {
      x = results.shift();
      if (x.kind === 'order_opened') {
        displayOpened(x.order || x.residual_order);
      }
      if (x.kind === 'order_filled' || x.kind === 'order_partially_filled') {
        _results.push(displaySold(x.order || x.filled_order));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  ensureKeys = function(obj, parts) {
    var cur;
    if (parts.length <= 1) {
      return obj;
    }
    cur = parts.shift();
    obj[cur] || (obj[cur] = {});
    return ensureKeys(obj[cur], parts);
  };

  global.test = {
    uses: function() {
      var resource;
      resource = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return resource.forEach(function(r) {
        var e, filename, key, owner, parts, _base;
        parts = r.split('.');
        filename = parts.map(function(p) {
          return p.toLowerCase();
        }).join('/');
        owner = ensureKeys(global, parts);
        key = parts[parts.length - 1];
        try {
          return owner[key] = require("../lib/" + filename);
        } catch (_error) {
          e = _error;
          console.log("warn: couldn't load ../lib/" + filename + " for " + r);
          if (!global.test.module_helpers[r]) {
            throw e;
          }
        } finally {
          if (typeof (_base = global.test.module_helpers)[r] === "function") {
            _base[r]();
          }
        }
      });
    }
  };

  global.test.module_helpers = {
    'Datastore.Amount': function() {
      global.Amount = global.Datastore.Amount;
      return global.amt = amt;
    },
    'Datastore.Ratio': function() {
      return global.Ratio = global.Datastore.Ratio;
    },
    'Datastore.Account': function() {
      return global.Account = global.Datastore.Account;
    },
    'Datastore.DataStore': function() {
      return global.DataStore = global.Datastore.DataStore;
    },
    'Datastore.BalanceSheet': function() {
      return global.BalanceSheet = global.Datastore.BalanceSheet;
    },
    'Datastore.SuperMarket': function() {
      return global.SuperMarket = global.Datastore.SuperMarket;
    },
    'Datastore.Market': function() {
      return global.Market = global.Datastore.Market;
    },
    'Datastore.Book': function() {
      return global.Book = global.Datastore.Book;
    },
    'Datastore.Order': function() {
      return global.Order = global.Datastore.Order;
    },
    'TradeEngine': function() {
      return global.TradeEngine = require("../lib/trade_engine");
    }
  };

}).call(this);
