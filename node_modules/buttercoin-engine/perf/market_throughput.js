// Generated by CoffeeScript 1.6.3
(function() {
  var Amount, DQ, Market, Order, Ratio, acctID, block_size, count, elapsedTime, hd, iterations, makeMatchingOrder, makeRandomOrder, market, mixAndMatch, n, orders, output_events, randomBool, randomInt, rl, startTime, _i, _results;

  hd = require('heapdump');

  Market = require('../lib/datastore/market');

  Order = require('../lib/datastore/order');

  Amount = require('../lib/datastore/amount');

  Ratio = require('../lib/datastore/ratio');

  DQ = require('deque');

  randomInt = function(lower, upper) {
    return Math.floor(Math.random() * (upper - lower + 1)) + lower;
  };

  randomBool = function() {
    return randomInt(0, 1);
  };

  acctID = 1;

  makeRandomOrder = function() {
    var currencies;
    currencies = ['BTC', 'USD'];
    if (randomBool()) {
      currencies = currencies.reverse();
    }
    return new Order({
      name: "user-" + (acctID++)
    }, currencies[0], new Amount(randomInt(1, 5000).toString()), currencies[1], new Amount(randomInt(1, 5000).toString()));
  };

  makeMatchingOrder = function(n) {
    var amt, currencies;
    currencies = n % 5 ? ['BTC', 'USD'] : ['USD', 'BTC'];
    amt = n % 5 ? 25 : 100;
    return new Order({
      name: "user-" + (acctID++)
    }, currencies[0], new Amount(amt.toString()), currencies[1], new Amount(amt.toString()));
  };

  mixAndMatch = function(n) {
    if ((n % 10) >= 5) {
      return makeRandomOrder();
    } else {
      return makeMatchingOrder(n);
    }
  };

  market = new Market('BTC', 'USD');

  count = 10000;

  block_size = 100;

  iterations = Math.floor(count / block_size);

  console.log("Generating " + block_size + " random orders...");

  orders = (function() {
    var _i, _results;
    _results = [];
    for (n = _i = 1; 1 <= block_size ? _i <= block_size : _i >= block_size; n = 1 <= block_size ? ++_i : --_i) {
      _results.push(makeMatchingOrder(n));
    }
    return _results;
  })();

  rl = require('readline').createInterface(process.stdin, process.stdout);

  rl.setPrompt('', 0);

  rl.clearLine = function() {
    if (process.platform === 'darwin') {
      return this.output.write("\u001B[2K\r");
    } else {
      return this.write(null, {
        ctrl: true,
        name: 'u'
      });
    }
  };

  rl.up = function(n) {
    if (n == null) {
      n = 1;
    }
    return this.output.write("\u001B[" + n + "A");
  };

  rl.down = function(n) {
    if (n == null) {
      n = 1;
    }
    return this.output.write("\u001B[" + n + "B");
  };

  rl.clearScreen = function() {
    this.output.write("\u001B[2J");
    return this.output.write("\u001B[H");
  };

  rl.on('SIGINT', function() {
    return process.exit(1);
  });

  output_events = 0;

  startTime = process.hrtime();

  (function() {
    _results = [];
    for (var _i = 1; 1 <= iterations ? _i <= iterations : _i >= iterations; 1 <= iterations ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).forEach(function(iterN) {
    var generation;
    generation = iterN * block_size;
    return orders.forEach(function(x, blockIdx) {
      var elapsedTime, idx;
      idx = generation + blockIdx;
      output_events += market.add_order(x).length;
      if ((idx % block_size) === 0) {
        elapsedTime = process.hrtime(startTime);
        elapsedTime = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000;
        rl.clearScreen();
        rl.write("" + ((elapsedTime / 1000).toFixed(1)) + " seconds (" + ((idx / count * 100).toFixed(2)) + "%)");
        rl.down();
        rl.clearLine();
        rl.write("--> " + ((idx / elapsedTime * 1000).toFixed(0)) + " tx/sec");
        rl.down();
        rl.clearLine();
        rl.write("--> " + ((output_events / elapsedTime * 1000).toFixed(0)) + " events/sec");
        rl.down();
        rl.clearLine();
        rl.write("--> " + Amount.flyweight_pool.length + "/" + Amount.num_allocated + " Amount objects in pool");
        rl.down();
        rl.clearLine();
        rl.write("--> " + Amount.num_put + " Amount objects put");
        rl.down();
        rl.clearLine();
        rl.write("--> " + Amount.num_took + " Amount objects took");
        rl.down();
        rl.clearLine();
        rl.write("--> " + Ratio.flyweight_pool.length + "/" + Ratio.num_allocated + " Ratio objects in pool");
        rl.down();
        rl.clearLine();
        rl.write("--> " + Ratio.num_put + " Ratio objects put");
        rl.down();
        rl.clearLine();
        rl.write("--> " + Ratio.num_took + " Ratio objects took");
        return rl.resume();
      }
    });
  });

  elapsedTime = process.hrtime(startTime);

  elapsedTime = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000;

  rl.clearScreen();

  rl.resume();

  rl.close();

  console.log("" + count + " transactions in " + (elapsedTime.toFixed(3)) + " ms");

  console.log("\t" + ((count / elapsedTime * 1000).toFixed(0)) + " tx/sec");

  console.log("performed " + output_events + " output events");

  console.log("\t" + ((output_events / elapsedTime * 1000).toFixed(0)) + " events/sec");

}).call(this);
